# 계산기 1

- 문자열로 된 계산식이 주어질 때, 스택을 이용하여 이 계산식의 값을 계산
- 문자열 수식 계산의 일반적 방법
  - 중위 표기법을 수식의 후위 표기법으로 변경(스택 이용)
    - 중위 표기법(infix notation) : 연산자를 피연산자의 가운데 표기하는 방법
      - A + B
    - 후위 표기법(postfix notation) : 연산자를 피연산자의 뒤에 표기하는 방법
      - AB +
  - 후위 표기법의 수식을 스택을 이용하여 계산

### 중위 표기법의 후위 표기법 전환 예시

- A*B-C/D
  - AB*CD/-
- (6+5*(2-8)/2)
  - 6528-*2/+

### 스택 이용 방법

- 토큰을 읽는다.
- 토큰이 피연산자이면 토큰을 출력
- 토큰이 연산자(괄호 포함)일 때, 이 토큰이 스택의 top에 저장되어 있는 연산자보다 우선순위가 높으면 스택에 push, 아니면 스택의 top의 연산자의 우선순위가 토큰의 우선순위보다 작을 때까지 pop한 후 토큰의 연산자를 push
- top에 연산자가 없으면 push
- 토큰이 닫는 괄호 ’)’ 이면 스택 top에 여는 괄호 ‘(’ 가 올때까지 스택에 pop 수행한 후, pop한 연산자 출력. 왼쪽 괄호를 만나면 pop만 하고 출력하지는 않음
- 중위 표기식에 더 읽을 것이 없다면 중지하고, 있으면 위 과정을 반복
- 스택에 남아있는 연산자를 모두 pop

### 스택을 이용한 후위표기법 계산

- 예시 : (6 + 5 * (2-8) / 2)
- 후위 표기법으로 전환 : 6528-*2/+
- 후위표기법을 읽으면서, 피연산자면 스택에 push
- 연산자가 나오면 스택에서 pop을 두번 하여 계산(첫 번째 pop의 결과가 뒤로 간 채로 계산해야 함)
- 연산의 결과를 다시 스택에 push
- 과정 예시

```python
# 후위 표기법 : 6528-*2/+

stk = [6, 5, 2, 8] # 연산자가 나올때까지 쭉 push

# '-' 연산자 등장

stk = [6, 5]

2 - 8 계산

# 계산 결과인 -6을 다시 stk에 push

stk = [6, 5, -6]

# '*' 연산자 등장

stk = [6]

5 * -6 계산

# 계산 결과인 -30을 다시 stk에 push

stk = [6, -30]

# 피연산자 '2' 등장, stk에 push

stk = [6, -30, 2]

# 연산자 '/' 등장

stk = [6]

-30 / 2 계산

# 계산 결과인 -15를 다시 stk에 push

stk = [6, -15]

# 연산자 '+' 등장

stk = []

6 + (-15) 계산

# 계산 결과인 -9를 stk에 push

stk = [-9]

ans = -9
```

# 백 트래킹(Backtracking)

- 백트래킹 기법은 해를 찾는 도중 막히면(즉, 해가 아니면) 되돌아가서 다시 해를 찾아 가는 기법
- 백트래킹 기법은 최적화 문제와 결정 문제를 해결 가능
  - 최적화 문제 : 가장 짧은 xx를 찾는 것
  - 결정 문제 : 문제의 조건을 만족하는 해가 존재하는지 판단하는 문제
    - 미로 문제, n-queen, map coloring, subset sum 등

## 백 트래킹 : 미로 찾기 알고리즘

- 델타 탐색을 통해, 이동이 가능한 방향으로 이동하면서 좌표를 스택에 push
- 길이 막히면 새로운 이동 가능 방향이 나올때까지 스택을 pop
- 새로운 이동 가능 경로가 나오면 위 과정을 반복

### 백 트래킹과 깊이 우선 탐색(DFS)의 차이

- 어떤 노드에서 출발하는 경로가 해결책으로 이어질 것 같지 않으면 더 이상 그 경로를 추적하지 않음으로써 시도의 횟수를 줄임(Prunning, 가지치기)
- 깊이 우선 탐색이 모든 경로를 추적하는데 비해 백 트래킹은 불필요한 경로를 조기에 차단
- 깊이 우선 탐색을 가하기에는 경우의 수가 너무 많음. 즉, N! 가지의 경우의 수를 가진 문제에 대해 깊이 우선 탐색을 가하면 당연히 처리 불가
- 백트래킹 알고리즘을 적용하면 일반적으로 경우의 수가 줄어들지만, 이 역시 최악의 경우에는 지수함수 시간(Exponential Time)을 요함

### 백 트래킹 기법

- 어떤 노드의 유망성을 점검한 뒤에, 유망(promising)하지 않다면, 그 노드의 부모로 되돌아가(backtracking) 다음 자식 노드로 감
- **유망성 : 특정 노드를 점검한 뒤에, 해당 경로가 최종 해답이 될 수 있는지를 체크하여, 가능하다면 유망하다고 판단**
- 가지치기(prunning) : 유망하지 않은 노드가 포함되는 경로는 더 이상 고려하지 않음
- 백트래킹의 작동 알고리즘
  - 상태 공간 트리의 깊이 우선 검색을 실시
  - 각 노드의 유망성을 점검
  - 노드가 유망하지 않다면 부모 노드로 돌아가서 재검색

### 백 트래킹을 이용하여 순열 구하기

```python
def backtrack(a, k, input):
    global MAXCANDIDATES
    c = [0] * MAXCANDIDATES

    if k == input:
        for i in range(1, k+1):
            print(a[i], end=' ')
        print()
    else:
        k += 1
        ncandidates = construct_candidates(a, k, input, c):
        for i in range(ncandidates):
            a[k] = c[i]
            backtrack(a, k, input)
```

```python
def construct_candidates(a, k, input, c):
    in_perm = [False] * NMAX

    for i in range(1, k):
        in_perm[a[i]] = True

    ncandidates = 0
    for i in range(1, input+1):
        if in_perm[i] == False:
            c[candidates] = i
            ncandidates += 1
    return ncandidates
```

- 강의 코드(부분집합 만들기)

```python
def f(i, N):
    if i == N:
        for i in range(N):
            if bit[i]:
                print(A[i], end=' ')
    else:
        bit[i] = 1
        f(i+1, N)
        bit[i] = 0
        f(i+1, N)

A = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

bit = [0] * 10

f(0, 10)
```

- 강의 코드(부분집합 합 검사)

```python
def f(i, N, s, t):
    global answer
    if i == N:
        if s == t:
            answer += 1
    elif s > t:
        return
    else:
        f(i+1, N, s+A[i], t) # A[i]가 포함된 경우
        f[i+1, N, s, t) # A[i]가 포함되지 않은 경우

A = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
bit = [0] * 10
answer = 0
f(0, 10, 0, 10)
print(answer)
```

- 강의 코드(순열 만들기)

```python
def f(i, N):
    if i == N:
        print(P)
    else:
        for j in range(i, N):
            P[i], P[j] = P[j], P[i]
            f(i+1, N)
            P[i], P[j] = P[j], P[i]

P = [1, 2, 3]
f(0, 3)
```

---

# 취업 특강

# 기업 분석

## 선배들의 실수 보완

- 회사가 어떤 사업을 운영하고 있고, 어떤 조직인지 이해하기
- 직무 정보를 숙지하기
- 작은 정보를 가지고 섣불리 판단하지 말기

## 기업 분석 시작하기

- 전반적인 경제상황 분석
  - 국내/외 이슈 파악
- 관련 산업에 대한 상황 분석
  - SW 업계의 산업 분석
- 산업 및 업종에 대한 기업 파악 및 타겟 기업 전반에 대한 분석
  - SI, 보안, 인터넷, 클라우드 등 기업 전반에 대한 분석

### 비전과 미션

- 비전 : 회사의 중장기적인 방향성
- 미션 : 회사의 존재 이유

## 왜 산업분석을 해야 하는가?

- 업종에 대한 이해
  - 이벤트형(레저, 바이오, 엔터)
  - 경기 순환형(건설, 금속, 자동차, 조선 ,해운)
  - 생활 밀착형(건강, 미용, 운수, 섬유, 패션, 음식료, 제지)
  - 지식 집약형(IT, 디스플레이, 반도체, 스마트폰, 의료기기, 통신)
- 이벤트형
  - 사회 이슈 및 트렌드나 기술에 따라 매출과 이익에 영향을 받음
  - 예측하기 어려운 구조이나, 기존의 성공경험과 인력, 영업망을 통해 기업과 채용을 예상해야 함
- 생활 밀착형
  - 생활 업종으로, 일상 생황에 소비되는 제품, 브랜드를 생산하는 업종
  - 브랜드 파워가 중요
  - 꾸준함이 중요
- 경기 순환형
  - 경기에 따라 호황, 불황의 사이클을 탐
  - 불황을 잘 이겨낼 수 있는 기업의 체력과 건실한 재무구조, 시장 지배력이 중요
- 지식 집약형
  - 지식의 변화가 빠른 분야, 따라잡지 못하면 뒤쳐짐
  - 연구개발에 대한 투자, 지재권 등의 역량이 중료

## 기업 분석을 어떻게 시작할까?

1. 기업 정보 조사
   - 기본 정보
     - 기업 홈페이지, 채용 페이지, 기업 SNS
   - 핵싱 점보
     - DART, NICE 기업정보, 블로터, 네이버 금융, 한경 컨센서스
   - 유용 정보
     - 검색 포털 사이트, 직장인 V-로그 등
2. 타겟기업 선정
3. 자료 분석/활용

## 기업 분석 방법(상장기업)

- 다트
- 네이버금융 & 에프앤가이드 상장기업분석
- 한경 컨센서스
- 워크넷
- 원티드
- The VC

### 스타트업 Round 단계

- 시드 → 시리즈A → 시리즈B → 시리즈C → 엑시트
